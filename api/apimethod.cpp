#include "apimethod.h"

#include <sys/time.h>
#include <stdio.h>

#include <QDebug>
#include <QCryptographicHash>

namespace API {

Method::Method(UserInfo *info, QNetworkAccessManager *manager, QObject *parent) :
    QObject(parent),
    m_userInfo(info),
    m_manager(manager)
{

}

Method::~Method() {

}

/*************************************************************************************/
/* The Observer class contains a single pure virtual function (processMethodResults) */
/* The reason I went this way is because once the QNetworkAccessManager returns the  */
/* QNetworkReply this object is no longer necessary. By requiring that all callers   */
/* inherit from Oberver we have a nice interface connecting them together and this   */
/* object can be safely disposed.                                                    */
/*************************************************************************************/
bool Method::execute(Observer *observer) {

    if (!validateArgs())
        return false;

    // THese are always constant with API requests
    m_argMap.insert("method", getMethodName());
    m_argMap.insert("api_key", m_userInfo->getApiKey());
    m_argMap.insert("v","1.0");
    m_argMap.insert("session_key",m_userInfo->getSessionKey());

    // This is going to have to be changed to something with greater than
    // second resolution (miliseconds or microseconds). Is there anything portable across
    // Mac/Win/Linux? Doubtful, have to build compile options for it.
    time_t tm = time(0);
    //char callId[30];
    //sprintf(callId, "%lld", tm);
    m_argMap.insert("call_id",(qlonglong)tm);


    // pull all the key/value pairs from the QMap and do the magic Facebook requires to
    // make an API call

    /********** From the Facebook API docs ****************************************
    The signature can be generated by calling generate_sig in facebook.php.
    generate_sig takes two parameters: an array of arg=val pairs and your app secret.
    The signature can also be constructed using the following algorithm
    (after all the other arguments have been determined):

    args = array of args to the request, not counting sig, formatted in non-urlencoded arg=val pairs
    sorted_array = alphabetically_sort_array_by_keys(args);
    request_str = concatenate_in_order(sorted_array);
    signature = md5(concatenate(request_str, secret))
    ***********************************************************************************/

    // In a way, this is really retarded. Facebook wants an MD5 hash of the args with no
    // serparators. You also need a set of args with '&' separated url encoded
    // key/value pairs for the actual post

    QByteArray sigByteArray;
    QByteArray postArgs;

    // QMap is automatically sorted by keys
    QMapIterator<QString, QVariant> i(m_argMap);
    while (i.hasNext()) {
         i.next();
         sigByteArray.append(i.key() + "=" + i.value().toString() );
         postArgs.append(i.key() + "=" + i.value().toString() + "&");
    }

    sigByteArray.append(m_userInfo->getSecret());

    QByteArray sig = QCryptographicHash::hash(sigByteArray,QCryptographicHash::Md5 );

    postArgs.append("sig=");
    postArgs.append(sig.toHex());

    QByteArray exclude("&=");
    QByteArray include;
    postArgs = postArgs.toPercentEncoding(exclude,include,'%');

    qDebug() << postArgs;

    QUrl url("http://api.facebook.com/restserver.php");

    QNetworkRequest nr;
    nr.setUrl(url);
    nr.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");

    QNetworkReply *reply;

    reply = m_manager->post(nr,postArgs);

    connect(reply, SIGNAL(finished()),
            observer, SLOT(processMethodResults(QNetworkReply*)));

    return true;

}

// virtual
bool Method::validateArgs() {
    return true;
}


} // namespace API
