#include "testqueryconsole.h"
#include "ui_testqueryconsole.h"
#include "api/factory.h"
#include "api/notification.h"


#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QStringList>
#include <QList>
#include <QMap>
#include <QCryptographicHash>
#include <QDebug>
#include <QByteArray>
#include <QTextDocument>

#include <sys/time.h>

TestQueryConsole::TestQueryConsole(UserInfo *userInfo, QWidget *parent) :
    QWidget(parent),
    ui(new Ui::TestQueryConsole)
{

    ui->setupUi(this);
    m_userInfo = userInfo;
    m_apiKey = m_userInfo->getApiKey();

    connect(ui->addButton, SIGNAL(clicked()),
            this, SLOT(addPostArgs()));

    connect(ui->sendButton, SIGNAL(clicked()),
            this, SLOT(sendQuery()));

    m_manager = new QNetworkAccessManager(this);
    connect(m_manager, SIGNAL(finished(QNetworkReply*)),
            this, SLOT(gotReply(QNetworkReply *)));

    API::Factory *factory = API::Factory::getInstance(m_userInfo);

    /*
    API::Method *method = factory->createMethod("friends.get");

    //connect(method, SIGNAL(methodComplete(API::Method*)),
    //        this, SLOT(methodReturned(API::Method*)));

    connect(factory, SIGNAL(apiFriendsGet(API::Friends::Get*)),
            this, SLOT(apiFriendsGet(API::Friends::Get*)));


    API::Method * method = factory->createMethod("notifications.getList");
    connect(factory, SIGNAL(apiNotificationsGetList(API::Notifications::GetList*)),
            this, SLOT(apiNotificationsGetList(API::Notifications::GetList*)));

    method->setArgument("include_read","true");


    bool rc = method->execute();
    if (!rc)
        qDebug() << method->getErrorStr();
    */
}

TestQueryConsole::~TestQueryConsole()
{
    delete ui;
}


void TestQueryConsole::addPostArgs() {

    if ((ui->postVarKey->text().compare("") != 0) && (ui->postVarValue->text().compare("") != 0))
        ui->encodedPostArgs->setPlainText(QString(ui->encodedPostArgs->toPlainText() +
                                              "&" + ui->postVarKey->text() + "=" +
                                              ui->postVarValue->text() ));

    ui->postVarKey->clear();
    ui->postVarValue->clear();


}

void TestQueryConsole::sendQuery() {

    // make sure we have a command
    if (ui->apiCallInput->text().compare("") == 0)
    {

        return;
    }

    // Build the post args from the input box
    QString origArgs = ui->encodedPostArgs->toPlainText();
    ui->encodedPostArgs->clear();
    if (origArgs.endsWith("&"))
        origArgs.chop(1);

    if (origArgs.startsWith("&"))
        origArgs.remove(0,1);

    // Some API commands need no additional options, and adding this & with
    // nothing in the editor makes split sad.
    if (origArgs.compare("") != 0)
        origArgs.append("&");

    origArgs.append("method=" + ui->apiCallInput->text() + "&api_key=" +
                    m_apiKey + "&v=1.0&session_key=" + m_userInfo->getSessionKey() +
                    "&call_id=");

    // This is going to have to be changed to something with greater than
    // second resolution in the main client. Is there anything portable across
    // Mac/Win/Linux? Doubtful, have to build compile options for it.
    time_t tm = time(0);
    char callId[30];
    sprintf(callId, "%d", tm);
    origArgs.append(callId);

    /*
    The signature can be generated by calling generate_sig in facebook.php.
    generate_sig takes two parameters: an array of arg=val pairs and your app secret.
    The signature can also be constructed using the following algorithm
    (after all the other arguments have been determined):

    args = array of args to the request, not counting sig, formatted in non-urlencoded arg=val pairs
    sorted_array = alphabetically_sort_array_by_keys(args);
    request_str = concatenate_in_order(sorted_array);
    signature = md5(concatenate(request_str, secret))
    */
    QMap<QString, QString> keyValuePairs;

    QStringList tmp(origArgs.split('&'));
    for (int i = 0; i < tmp.size(); i++) {
        QStringList tmp2(tmp.at(i).split('='));
        keyValuePairs.insert(tmp2.at(0), tmp2.at(1));
    }


    QByteArray sigByteArray;
    // QMap is automatically sorted by keys
    QMapIterator<QString, QString> i(keyValuePairs);
    while (i.hasNext()) {
         i.next();
         sigByteArray.append(i.key() + "=" + i.value());
    }
    sigByteArray.append(m_userInfo->getSecret());

    qDebug() << sigByteArray;

    QByteArray args;
    QByteArray sig = QCryptographicHash::hash(sigByteArray,QCryptographicHash::Md5 );

    args.append(origArgs.toAscii());
    QByteArray exclude("&=");
    QByteArray include;
    QByteArray encodedArgs = args.toPercentEncoding(exclude,include,'%');

    encodedArgs.append("&sig=");
    encodedArgs.append(sig.toHex());

    qDebug() << encodedArgs;



    QUrl url("http://api.facebook.com/restserver.php");


    QNetworkRequest nr;
    nr.setUrl(url);
    nr.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");
    QNetworkReply *reply = 0;


    reply = m_manager->post(nr,encodedArgs);



}

void TestQueryConsole::gotReply(QNetworkReply *reply) {

    if (reply->error() > 0) {
        qDebug() << "Error number = " << reply->errorString();
    }
    else {
        QByteArray data = reply->readAll();
        ui->outputFrame->setText(QString(data));
    }

    reply->deleteLater();

}

void TestQueryConsole::methodReturned(API::Method *method) {

    qDebug() << "methodReturned()";

    if (method->getMethodName() == "friends.get")
    {
        API::Friends::Get *fgMethod = (API::Friends::Get *)method;
        QStringList friends = fgMethod->getFriendIdList();

        ui->outputFrame->append("\n\nHere are the uids for your " + QString::number(friends.size()) + " friends\n");

        for (int i = 0; i < friends.size(); i++)
            ui->outputFrame->append(friends.at(i));
    }

    method->deleteLater();

}

void TestQueryConsole::apiNotificationsGetList(API::Notifications::GetList *method) {

    qDebug() << "apiNotificationsGetList()";

    QList<API::Notifications::Notification> list;
    list = method->getNotifications();
    // list = method->getNotifications();

    //ui->outputFrame->acceptRichText();
    //for (int i =0; i < list.size(); i++)
    while (!list.empty())
    {
        API::Notifications::Notification n = list.takeFirst();
        if (n.getIsHidden() == false) {
            ui->outputFrame->textCursor().insertHtml(n.getTitleHtml());
            ui->outputFrame->textCursor().insertHtml("<BR>");
            //ui->outputFrame->append(list->at(i)->getTitleHtml());
            ui->outputFrame->textCursor().insertHtml(n.getBodyHtml());
            //ui->outputFrame->append(list->at(i)->getBodyText());
            ui->outputFrame->textCursor().insertHtml("<BR><BR>");
        }
    }

    method->deleteLater();

}

void TestQueryConsole::apiFriendsGet(API::Friends::Get *fgMethod) {

    qDebug() << "apiFriendsGet()";

    QStringList friends = fgMethod->getFriendIdList();

    ui->outputFrame->append("\n\nHere are the uids for your " + QString::number(friends.size()) + " friends\n");

    for (int i = 0; i < friends.size(); i++)
        ui->outputFrame->append(friends.at(i));


    fgMethod->deleteLater();

}
void TestQueryConsole::changeEvent(QEvent *e)
{
    QWidget::changeEvent(e);
    switch (e->type()) {
    case QEvent::LanguageChange:
        ui->retranslateUi(this);
        break;
    default:
        break;
    }
}
